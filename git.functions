#!/bin/bash -u
#
# Copyright (c) Roberto A. Foglietta, 2022-2023
#
# Authors:
#  Roberto A. Foglietta <roberto.foglietta@gmail.com>
#
# SPDX-License-Identifier: GPLv3
#

SRC_FILE=$(readlink -f ${BASH_SOURCE[0]})
export gfrefdir_path="$(dirname ${SRC_FILE})"
export gfreload_pathname="${SRC_FILE}"
source "${gfrefdir_path}/colors.shell"

if ! echo "${PATH}" | egrep -q $gfrefdir_path; then
    export PATH="$gfrefdir_path/bin:${PATH}"
fi

export BRNC_SWTC_PREV_BRNC=${BRNC_SWTC_PREV_BRNC:-}
export BRNC_SWTC_PREV_HASH=${BRNC_SWTC_PREV_HASH:-}

function _op_action() {
    local op ret
    case "${1:-}" in
    c) op="cherry-pick"
        ;;
    m) op="merge"
        ;;
    r) op="rebase"
        ;;
    *) op=$(opst)
       ;;
    esac
    _git ${op:-none} $2 || return $?
    test -z "$op" || echo -e "\ngit ${op} $2: ${OK}\n"
}
export -f _op_action

test ${gflistshow:-0} -ne 0 && set -x #########################################

#if [ -r "${gfrefdir_path}/isatty_override.so" ]; then
#   this could be useful for the future
#fi

function pipenull() {
    tail -n0 -
    return ${PIPESTATUS}
}
export -f pipenull

function redef_git() {
    unset -f _git
    if [ "x${1:-}" == "x-u" ]; then
        function _git() { ugit "$@"; }
    else
        eval 'function _git() { '"$@"'; }'
    fi
    export -f _git
}
export -f redef_git

function reset_git() {
    unset -f _git
    function _git() { command git "$@"; }
    export -f _git
}
export -f reset_git

reset_git #####################################################################

function less() {
    command less -Fr "$@"
}
export -f less

function egnc() {
    command egrep --color=never "$@"
}
export -f egnc

function gitshell() {
    local gitrc=$(mktemp -p "${TMPDIR:-}")
    declare -i ret=0
    if true; then
        cat "${gfrefdir_path}/colors.shell"
        egnc -v "source.*colors.shell"  "${gfreload_pathname}"
        echo 'export PS1="\[${nlcyn}\]${gitshell_prefix}\[${crst}\]:\[${nlgrn}\]git-\$(opst||printf 'shell')\[${crst}\]:\[${nlylw}\]\$(bcur||hcur)\[${crst}\]> "'
        echo "export term=XTERM"
        echo "$@"
    fi > "$gitrc"; chmod a-w "$gitrc"
    bash --rcfile "$gitrc" -ri 3>/dev/null || ret=$?
    unset gitshell_prefix
    rm -f "$gitrc"
    return $ret
}

function ce() {
    test -z "${1:-}" && return 1
    declare -i ret=0 quit=0
    if [ "x${1:-}" == "x--abort" -a -n "${commit_edit_head}" ]; then
        git reset --hard ${commit_edit_head} && abrt || ret=$?
        quit=1
    else
        export gitshell_prefix="ce"
        export commit_edit_note=\
"enter 'ce --abort' to abort and exit + "\
"'cm' uses '--amend' by default here, enjoy."
        export commit_edit_opts="--amend"
        export commit_edit_brch="$(bcur)"
        export commit_edit_head="$(hcur)"
        export commit_edit_csha="${1:-$commit_edit_head}"
        function exit() {
            local op=$(opst)
            if [ -n "$op" ]; then
                echo -e "\n${WARNING}: ${op} in progress, please complete the job or abort it."
                echo -e "\n${NOTICE} : enter 'ce --abort' to abort and exit or 'command exit' to exit.\n"
                return 1
            fi
            command exit ${1:-}
        }; export -pf exit
        gitshell "$(declare -pf exit); git commit-edit ""$@"' || exit $?' || ret=$?
        unset -f exit
    fi
    unset commit_edit_opts commit_edit_brch \
          commit_edit_head commit_edit_csha
    test $quit -ne 0 && command exit $ret
    return $ret
}


function pa() {
    test -z "${1:-}" && return 1
    redef_git -u
    for i in "$@"; do
        if _git apply --check --stat "$i" && \
           _git am -p1 --keep-cr --signoff "$i" \
        && sw -P; then
            echo -e "\n${DONE}: applying '$(basename $i)'.\n"
        else
            echo -e "\n${ERROR}: applying '$(basename $i)', abort.\n"
            break
        fi
    done
    reset_git
}
export -f pa

function ugit() {
    declare -i ret=0
    local solib="${gfrefdir_path}/isatty_override.so"
    test -r "${solib}" || solib=""
    LD_PRELOAD="${solib}" git -P "$@" || ret=$?
    echo; return $ret
}
export -f ugit

function gfreload() {
    test -z "${1:-}" && p="${gfreload_pathname}" || p="$1"
    if source "$p"; then
        gfreload_pathname="$p"
        gfrefdir_path=$(dirname "$p")
        echo -e "\n${DONE}: install path ${gfrefdir_path}\n"
    fi
}
export -f gfreload

function gfupdate() {
    ${gfreload_pathname/git.functions/install.sh} update
}
export -f gfupdate

function gflist() {
    gflistshow=1
    gfreload 2>&1 | sed -ne "s,.*export -f ,,p"
    gflistshow=0
}
export -f gflist

function gfhelp() {
    echo -e "\n${USAGE}: $(gflist | tr '\n' ' ')\n"
    echo -e "${NOTICE}: install path ${gfrefdir_path}\n"
}
export -f gfhelp

function irebase() {
    if [ -z "${1:-}" ]; then irebase HEAD; return $?; fi
    if [ "x${1:0:1}" == "x~" -o "x${1:0:1}" == "x-" ]; then
        test -z "${1:1}" || \
            irebase HEAD~${1:1}
        return $?
    fi
    local hash=$(_git rev-list --parents -n2 "$1" | tail -n1 | head -c40)
    test -n "$hash" && _git rebase -i $hash
}
export -f irebase

function repshrink() {
	_git reflog | egrep .
	_git gc --auto
	_git maintenance run --auto
	_git reflog expire --expire=now --all && \
        _git gc --prune=now --aggressive
}
export -f repshrink

function lg() {
	_git log --abbrev-commit --format=format:'* %C(bold cyan)%h%C(reset) - %C(white)%s%C(reset) %C(bold green)%d%C(reset)' "$@"
}
export -f lg

function lgnc() {
	_git log --abbrev-commit --format=format:'* %h - %s %d' "$@"
}
export -f lgnc

function lg1() {
	lg -n1 "$@"
}
export -f lg1

function lt() {
	_git log --graph --abbrev-commit --decorate --format=format:'%C(bold cyan)%h%C(reset) - %C(white)%s%C(reset) %C(bold green)%d%C(reset)' --all "$@"
}
export -f lt

function st() {
	_git status "$@"
}
export -f st

function ff() {
	local opt
	if [ "${1:-}" == "-s" ]; then
		opt="--staged"
		shift
	elif [ "${1:-}" == "-o" ]; then
        opt="origin/${2:-$(bcur)}"
		shift
	fi
	_git diff $opt "$@"
}
export -f ff

function rl() {
	_git reflog "$@"
}
export -f rl

function reflog() {
	rl "$@"
}
export -f reflog

function add() {
	_git add "$@"
}
export -f add

function cm() {
	_git commit ${commit_edit_opts} --signoff "$@"
}
export -f cm

function am() {
	_git commit --amend "$@"
}
export -f am

function amend() {
	am "$@"
}
export -f amend

function editorset() {
    test -z "${1:-}" && return 1
    _git config --global core.editor "$1"
}
export -f editorset

function rpull() {
	_git pull --rebase "$@"
}
export -f rpull

function push() {
	_git push "$@"
}
export -f push

function fpush() {
	_git push --force "$@"
}
export -f fpush

function co() {
    _git checkout "$@"
}
export -f co

function sw() {
    if [ "x${1:-}" == "x-P" ]; then
        shift; ugit show "$@"
    else
	    _git show "$@"
    fi
}
export -f sw

function sf() {
    _git show --raw "$@" | egrep "^:[0-9]*" | awk '{ print $6 }'
}
export -f sf

function forig() {
    _git fetch origin "$@"
}
export -f forig

function pcache() {
	local -i t=3600 runcmd=1
	local d=$(_git rev-parse --show-toplevel)
	if [ "x${1:-}" == "x--save" -a -n "${2:-}" ]; then
		echo "$2" > $d/.gitpasswd
		echo -e "\n${NOTICE}: password saved in $d/.gitpasswd\n"
        if true; then
            history -d -2 || history -c
        fi 2>&1 | pipenull
		shift 2
	elif [ "x${1:-}" == "x--stop" ]; then
		t=0; runcmd=0
	elif [ "x${1:-}" == "x--time" -a -n "${2:-}" ]; then
		t=$2; [ $t -lt 600 ] && t=600
		echo -e "\n${NOTICE}: timeout '$2' has been set to $t seconds\n"
		shift 2
	elif [ "x${1:-}" == "x--help" ]; then
		echo -e "\n${USAGE}: cchace [ --time 14400 | --save '.gitpasswd' | --stop | --help ]\n"
		return
	fi
	_git config credential.helper store
	_git config credential.helper "cache --timeout=$t"
	if [ "$t" == "0" ]; then
		echo -e "${DONE}: git password cache disabled"
	else
		if [ -r "$d/.gitpasswd" ]; then
            if [ ! -e "$d/.gitignore" ]; then
				echo "/.gitpasswd" >> "$d/.gitignore"
			elif ! grep -q "/.gitpasswd" "$d/.gitignore"; then
				echo "/.gitpasswd" >> "$d/.gitignore"
			fi
            st "$d/.gitignore" | egrep -q .gitignore \
                && echo -e "\n${WARNING}: add .gitignore and commit the change\n"
			_git -c credential.helper='!f() { echo "password=$(cat '$d/.gitpasswd')"; }; f' push --dry-run
		else
			forig
		fi
		echo -e "${DONE}: git password cache enable for ${t}s eq. to $[t/3600]h $[(t%3600)/60]m $[t%60]s\n"
	fi
	test  "${1:-}" != "" -a "$runcmd" == "1" && eval "$@"
}
export -f pcache

function opst() {
    st -v | grep -v "git commit --amend" |\
        sed -ne 's,.*[userun]\{3\} .git \(.*\) --.*,\1,p' |\
            sort | head -n1
}
export -f opst

function cont() {
    _op_action "${1:-}" --continue
}
export -f cont

function abrt() {
    _op_action "${1:-}" --abort
}
export -f abrt

function todo() {
   _op_action "${1:-}" --edit-todo
}
export -f todo

function skip() {
   _op_action "${1:-}" --skip
}
export -f skip

function stash() {
    _git stash "$@"
}
export -f stash

function pop() {
	_git stash pop "$@"
}
export -f pop

function tagdel() {
    test -z "${1:-}" && return 1
    _git push --delete origin "$1"
    _git tag -d "$@"
}
export -f tagdel

function tagadd() {
    test -z "${1:-}" && return 1
    local tag="$1"; shift
    _git tag -a "$tag" "$@" -m "$tag" && \
        _git push origin --tags
}
export -f tagadd

function pull() {
	_git pull "$@"
}
export -f pull

function fpatch() {
    test -z "${1:-}" && return 1
	_git format-patch -1 "$@"
}
export -f fpatch

function chpk() {
	for i in "$@"; do
		_git cherry-pick $i || return $?
	done
}
export -f chpk

function lsbr() {
    _git branch -r | grep -ve "/HEAD$" -ve "/HEAD " | cut -d/ -f2-
}
export -f lsbr

export BRNC_SWTC_CURR_BRNC="${BRNC_SWTC_CURR_BRNC:-}"

function bsw() {
    test -z "${1:-}" && return 1
    local cb="$(bcur)" ch=$(hcur) nb=""
          cb=${cb:-$BRNC_SWTC_CURR_BRNC}
    if [ "x$1" == "x-" -a -n "${2:-}" ]; then
        return 1
    else
        if [ "x$1" == "x-" ]; then
            nb="${BRNC_SWTC_PREV_BRNC:-$cb}"
            set --
        fi
    fi
    declare -i ret=0
    if _git switch "$@" ${nb}; then
        BRNC_SWTC_PREV_BRNC="${cb}"
        if [ -n "${nb}" -a "$(hcur)" != "${BRNC_SWTC_PREV_HASH}" ]; then
            co ${BRNC_SWTC_PREV_HASH} 2>&1 | head -n1
            ret=${PIPESTATUS}
        else
            nb=$(bcur)
        fi
        BRNC_SWTC_PREV_HASH="${ch}"
        BRNC_SWTC_CURR_BRNC="${nb}"
    else
        ret=1
    fi
    return $ret
}
export -f bsw

function bcur() {
    _git branch --show-current | egnc .
}
export -f bcur

function hcur() {
    _git rev-parse --short HEAD | egnc .
}
export -f hcur

function for-all-other-branches() {
    test -z "${1:-}" && return 1

    local cur=$(bcur)
    if [ "$cur" == "" ]; then
        echo -e "${ERROR}: this is not the HEAD of a branch." >&2
        return 1
    fi

    declare -i nbr=$(lsbr | wc -l)
    if [ $nbr -le 1 ]; then
        echo -e "${DONE}: there is only one branch '$cur' as current." >&2
        return 0
    fi

    if echo "x$@" | grep -q "fpush"; then
        echo -e "${ERROR}: fpush is not allowed for safety." >&2
        return 1
    fi
    if echo "x$@" | grep -qe "push.*-f"; then
        echo -e "${ERROR}: push -f is not allowed for safety." >&2
        return 1
    fi
    if echo "x$@" | grep -q -- "--force"; then
        echo -e "${ERROR}: option --force is not allowed for safety." >&2
        return 1
    fi

    local rpull="true" stashpop=0 nofail=""
    while true; do
        if [ "x$1" == "x-p" ]; then
            rpull="pull"
        elif [ "x$1" == "x-r" ]; then
            rpull="rpull"
        elif [ "x$1" == "x-a" ]; then
            BRANCHES=$(lsbr)
        elif [ "x$1" == "x-s" ]; then
            stashpop=1
        elif [ "x$1" == "x-n" ]; then
            nofail="; true"
        else
            break
        fi
        shift
    done

    if [ $stashpop -eq 0 ]; then
        local warn=$(st | grep -e "^Changes [not]* ")
        if [ -n "$warn" ]; then
            echo -e "${WARNING}: changes pending, please stash (-s) or commit." >&2
            return 1
        fi
    fi

    local curdir=$(readlink -f $PWD)
    local topdir=$(readlink -f $(_git rev-parse --show-toplevel))
    if [ "$curdir" == "$topdir" ]; then
        true
    elif ! cd $topdir; then
        echo -e "${ERROR}: cannot change folder to the top level." >&2
        return 1
    fi
    forig || return $?

    test $stashpop -ne 0 && stash

    declare -i ret=0
    BRANCHES=${BRANCHES:-$(lsbr | grep -vwe "$cur")}
	for branch in ${BRANCHES}; do
        if ! bsw $branch; then
            echo
            echo -e "${bylw}branch: $branch, SKIP${crst}"
            echo "press ENTER to continue..."
            read
        elif eval "$rpull" && eval "$@""${nofail}"; then
            echo
            echo -e "${blgrn}branch: $branch, OK${crst}"
            echo
        else
            echo
            echo -e "${blred}branch: $branch, KO${crst}"
            echo "fix the problem and then enter 'exit'"
            echo "or enter 'exit 1' to abort completely"
            echo
            gitshell || ret=$?
        fi
	done
    unset BRANCHES
    test "$cur" != "$branch" && bsw $cur
    test $stashpop -ne 0 && pop
    return $ret
}
export -f for-all-other-branches

function lgrp() {
    declare -i shaonly=0
    if [ "${1:-}" == "-s" ]; then
        shaonly=1
        shift
    fi
    test -z "${1:-}" && return 1
    local strn="$1"; shift

    redef_git -u
    if [ $shaonly -ne 0 ]; then
        lgnc "$@" | egnc "$strn" | awk '{print $2}'
    else
        lg "$@" | egrep "$strn"
    fi
    ret=${PIPESTATUS[1]}
    reset_git

    return $ret
}
export -f lgrp

function tagl() {
    _git tag -l "$@"
}
export -f tagl

test ${gflistshow:-0} -ne 0 && set +x #########################################

true
